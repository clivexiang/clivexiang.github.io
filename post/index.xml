<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Posts on clive xiang 的博客</title>
    <link>http://localhost:1313/post/</link>
    <description>Recent content in Posts on clive xiang 的博客</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en</language>
    <lastBuildDate>Wed, 21 Oct 2020 21:18:22 +0800</lastBuildDate>
    
	<atom:link href="http://localhost:1313/post/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>Nginx 常见使用场景</title>
      <link>http://localhost:1313/post/nginx/nginx-use/</link>
      <pubDate>Mon, 19 Oct 2020 20:25:50 +0800</pubDate>
      
      <guid>http://localhost:1313/post/nginx/nginx-use/</guid>
      <description>跨域问题 在工作中，有时候会遇到一些接口不支持跨域，这时候可以简单的添加 add_headers 来支持 cors 跨域。配置如下： server { listen 80; server_name api.xxx.com; add_header &#39;Access-Control-Allow-Origin&#39; &#39;*&#39;; add_header &#39;Access-Control-Allow-Credentials&#39; &#39;true&#39;; add_header &#39;Access-Control-Allow-Methods&#39; &#39;GET,POST,HEAD&#39;; location / { proxy_pass http://127.0.0.1:3000; proxy_set_header X-Real-IP</description>
    </item>
    
    <item>
      <title>Python Ansible 自动化部署 K8S 集群 </title>
      <link>http://localhost:1313/post/k8s/python-ansible/</link>
      <pubDate>Mon, 19 Oct 2020 15:45:06 +0800</pubDate>
      
      <guid>http://localhost:1313/post/k8s/python-ansible/</guid>
      <description>1.1 Ansible 介绍 Ansible 是一种 IT 自动化工具。它可以配置系统，部署软件以及协调更高级的 IT 任务，例如持续部署，滚动更新。Ansible 适用于管理企业 IT 基础设施</description>
    </item>
    
    <item>
      <title>Http 反向代理</title>
      <link>http://localhost:1313/post/jane-theme-preview.zh-cn/</link>
      <pubDate>Tue, 06 Mar 2018 16:01:23 +0800</pubDate>
      
      <guid>http://localhost:1313/post/jane-theme-preview.zh-cn/</guid>
      <description>Http 反向代理 我们先实现一个小目标：不考虑复杂的配置，仅仅是完成一个 http 反向代理。 nginx.conf 配置文件如下: #运行用户 #user somebody; #启动进程,通常设置成和cpu的数</description>
    </item>
    
    <item>
      <title>Go 方法</title>
      <link>http://localhost:1313/post/go/go-methods/</link>
      <pubDate>Wed, 21 Oct 2020 21:18:22 +0800</pubDate>
      
      <guid>http://localhost:1313/post/go/go-methods/</guid>
      <description>Go 没有类。不过你可以为结构体类型定义方法。 方法就是一类带特殊的 接收者 参数的函数。 方法接收者在它自己的参数列表内，位于 func 关键字和方法名之间。 在</description>
    </item>
    
    <item>
      <title>Go Map</title>
      <link>http://localhost:1313/post/go/go-map/</link>
      <pubDate>Wed, 21 Oct 2020 21:13:22 +0800</pubDate>
      
      <guid>http://localhost:1313/post/go/go-map/</guid>
      <description>映射的文法 映射的文法与结构体相似，不过必须有键名。 map-literals.go package main import &amp;quot;fmt&amp;quot; type Vertex struct { Lat, Long float64 } var m = map[string]Vertex{ &amp;quot;Bell Labs&amp;quot;: Vertex{ 40.68433, -74.39967, }, &amp;quot;Google&amp;quot;: Vertex{ 37.42202, -122.08408, }, } func main() { fmt.Println(m) } 若顶级类型只是一个类型</description>
    </item>
    
    <item>
      <title>Go Pointer</title>
      <link>http://localhost:1313/post/go/go-pointer/</link>
      <pubDate>Wed, 21 Oct 2020 20:54:41 +0800</pubDate>
      
      <guid>http://localhost:1313/post/go/go-pointer/</guid>
      <description>Go 拥有指针。指针保存了值的内存地址。 类型 *T 是指向 T 类型值的指针。其零值为 nil。 var p *int &amp;amp; 操作符会生成一个指向其操作数的指针。 i := 42 p = &amp;amp;i * 操</description>
    </item>
    
    <item>
      <title>Go Struct</title>
      <link>http://localhost:1313/post/go/go-struct/</link>
      <pubDate>Wed, 21 Oct 2020 19:54:41 +0800</pubDate>
      
      <guid>http://localhost:1313/post/go/go-struct/</guid>
      <description>一个结构体（struct）就是一组字段（field） structs.go package main import &amp;quot;fmt&amp;quot; type Vertex struct { X int Y int } func main() { fmt.Println(Vertex{1, 2}) } 结构体字段使用点号来访问。 struct-fields.go package main import &amp;quot;fmt&amp;quot; type Vertex struct { X int</description>
    </item>
    
    <item>
      <title>Go Defer</title>
      <link>http://localhost:1313/post/go/go-defer/</link>
      <pubDate>Tue, 20 Oct 2020 20:10:12 +0800</pubDate>
      
      <guid>http://localhost:1313/post/go/go-defer/</guid>
      <description>defer 语句会将函数推迟到外层函数返回之后执行。 推迟调用的函数其参数会立即求值，但直到外层函数返回前该函数都不会被调用。 defer.go package main import &amp;quot;fmt&amp;quot; func main() { defer fmt.Println(&amp;quot;world&amp;quot;) fmt.Println(&amp;quot;hello&amp;quot;) } defer</description>
    </item>
    
    <item>
      <title>Go For</title>
      <link>http://localhost:1313/post/go/go-for/</link>
      <pubDate>Tue, 20 Oct 2020 20:04:12 +0800</pubDate>
      
      <guid>http://localhost:1313/post/go/go-for/</guid>
      <description>Go 只有一种循环结构：for 循环。 基本的 for 循环由三部分组成，它们用分号隔开： 初始化语句：在第一次迭代前执行 条件表达式：在每次迭代前求值 后置语句</description>
    </item>
    
    <item>
      <title>Go if</title>
      <link>http://localhost:1313/post/go/go-if/</link>
      <pubDate>Tue, 20 Oct 2020 20:04:12 +0800</pubDate>
      
      <guid>http://localhost:1313/post/go/go-if/</guid>
      <description>Go 的 if 语句与 for 循环类似，表达式外无需小括号 ( ) ，而大括号 { } 则是必须的。 if.go package main import ( &amp;quot;fmt&amp;quot; &amp;quot;math&amp;quot; ) func sqrt(x float64) string { if x &amp;lt; 0 { return sqrt(-x) + &amp;quot;i&amp;quot; } return fmt.Sprint(math.Sqrt(x)) } func main() { fmt.Println(sqrt(2), sqrt(-4)) } if 的</description>
    </item>
    
    <item>
      <title>Go Pakage</title>
      <link>http://localhost:1313/post/go/go-pakage/</link>
      <pubDate>Tue, 20 Oct 2020 20:04:12 +0800</pubDate>
      
      <guid>http://localhost:1313/post/go/go-pakage/</guid>
      <description>每个 Go 程序都是由包构成的。 程序从 main 包开始运行。 本程序通过导入路径 &amp;ldquo;fmt&amp;rdquo; 和 &amp;ldquo;math/rand&amp;rdquo; 来使用这两个包。 按照约定，包名与导入路径的最后一个元素一致。例如，&amp;l</description>
    </item>
    
    <item>
      <title>Go switch</title>
      <link>http://localhost:1313/post/go/go-switch/</link>
      <pubDate>Tue, 20 Oct 2020 20:04:12 +0800</pubDate>
      
      <guid>http://localhost:1313/post/go/go-switch/</guid>
      <description>switch 的求值顺序 switch 的 case 语句从上到下顺次执行，直到匹配成功时停止。 （例如， switch i { case 0: case f(): } 在 i==0 时 f 不会被调用。） switch-evaluation-order.go package main import ( &amp;quot;fmt&amp;quot; &amp;quot;time&amp;quot; ) func main() { fmt.Println(&amp;quot;When&#39;s Saturday?&amp;quot;) today := time.Now().Weekday() switch</description>
    </item>
    
    <item>
      <title>Go 基本数据类型 变量</title>
      <link>http://localhost:1313/post/go/go-type/</link>
      <pubDate>Tue, 20 Oct 2020 20:04:12 +0800</pubDate>
      
      <guid>http://localhost:1313/post/go/go-type/</guid>
      <description>变量 var 语句用于声明一个变量列表，跟函数的参数列表一样，类型在最后。 就像在这个例子中看到的一样，var 语句可以出现在包或函数级别。 variables.go package main import &amp;quot;fmt&amp;quot; var</description>
    </item>
    
    <item>
      <title>Nginx 常用命令</title>
      <link>http://localhost:1313/post/nginx/nginx-demo/</link>
      <pubDate>Mon, 19 Oct 2020 20:25:50 +0800</pubDate>
      
      <guid>http://localhost:1313/post/nginx/nginx-demo/</guid>
      <description>nginx 的使用比较简单，就是几条命令。 常用到的命令如下： nginx -s stop 快速关闭 Nginx，可能不保存相关信息，并迅速终止 web 服务。 nginx -s quit 平稳关闭 Nginx，</description>
    </item>
    
    <item>
      <title>Nginx 常见错误</title>
      <link>http://localhost:1313/post/nginx/nginx-error/</link>
      <pubDate>Mon, 19 Oct 2020 20:25:50 +0800</pubDate>
      
      <guid>http://localhost:1313/post/nginx/nginx-error/</guid>
      <description>The plain HTTP request was sent to HTTPS port 解决办法，fastcgi_param HTTPS $https if_not_empty 添加这条规则， server { listen 443 ssl; # 注意这条规则 server_name my.domain.com; fastcgi_param HTTPS $https if_not_empty; fastcgi_param HTTPS on; ssl_certificate /etc/ssl/certs/your.pem; ssl_certificate_key /etc/ssl/private/your.key; location / { # Your config here... }</description>
    </item>
    
    <item>
      <title>Helm 应用包管理器</title>
      <link>http://localhost:1313/post/k8s/helm/</link>
      <pubDate>Mon, 19 Oct 2020 17:00:42 +0800</pubDate>
      
      <guid>http://localhost:1313/post/k8s/helm/</guid>
      <description>3.1 为什么需要 Helm？ K8S 上的应用对象，都是由特定的资源描述组成，包括 deployment、service 等。都保存各自文件中或者集中写到一个</description>
    </item>
    
    <item>
      <title>Docker Command</title>
      <link>http://localhost:1313/post/k8s/docker-command/</link>
      <pubDate>Mon, 19 Oct 2020 14:22:38 +0800</pubDate>
      
      <guid>http://localhost:1313/post/k8s/docker-command/</guid>
      <description>杀死所有正在运行的容器 docker kill $(docker ps -a -q) 删除所有已经停止的容器 docker rm $(docker ps -a -q) 删除所有未打 dangling 标签的镜 docker rmi $(docker images -q -f dangling=true) 删除所有镜像 docker rmi $(docker images -q) 强制删除 无法删</description>
    </item>
    
    <item>
      <title>Https 反向代理</title>
      <link>http://localhost:1313/post/nginx/nginx-https/</link>
      <pubDate>Sat, 19 Sep 2020 17:00:42 +0800</pubDate>
      
      <guid>http://localhost:1313/post/nginx/nginx-https/</guid>
      <description>Https 反向代理 一些对安全性要求比较高的站点，可能会使用 HTTPS（一种使用 ssl 通信标准的安全 HTTP 协议）。 这里不科普 HTTP 协议和 SSL 标准。但是，使用 nginx 配置 https</description>
    </item>
    
    <item>
      <title>Https 负载均衡</title>
      <link>http://localhost:1313/post/nginx/nginx-upstrem/</link>
      <pubDate>Sat, 19 Sep 2020 17:00:42 +0800</pubDate>
      
      <guid>http://localhost:1313/post/nginx/nginx-upstrem/</guid>
      <description>nginx 实现简单的负载均衡功能。 假设这样一个应用场景：将应用部署在 192.168.1.11:80、192.168.1.12:80、192.168.</description>
    </item>
    
    <item>
      <title>Math Preview</title>
      <link>http://localhost:1313/post/math-preview/</link>
      <pubDate>Mon, 04 Mar 2019 16:01:23 +0800</pubDate>
      
      <guid>http://localhost:1313/post/math-preview/</guid>
      <description>&lt;p&gt;&lt;a href=&#34;https://www.intmath.com/cg5/katex-mathjax-comparison.php&#34;&gt;KaTeX and MathJax Comparison Demo, currently processed as KaTex&lt;/a&gt;&lt;/p&gt;</description>
    </item>
    
  </channel>
</rss>